(ns btclj.ecc.finite-field-point
  (:require [btclj.ecc.finite-field :as ff]
            [clojure.pprint :as pprint]))

(defn in? [[x y]  [a b]]
  (= (ff/pow y 2)
     (ff/add
      (ff/add (ff/pow x 3)
              (ff/mul a x)) b)))

(defn infinity-point [prime]
  [[##Inf prime] [##Inf prime]])


(defn add [p1 p2 a _]
  (let [[x1 y1] p1
        [x2 y2] p2]
    (cond
      (infinite? (first x1)) p2
      (infinite? (first x2)) p1
      (and (= x1 x2)
           (not= y1 y2)) (infinity-point (second x1))

      (= p1 p2) (let [s (ff/div (ff/add
                                 (ff/smul
                                  (ff/pow x1 2) 3) a)
                                (ff/smul y1 2))
                      x3 (ff/sub (ff/pow s 2)
                                 (ff/smul x1 2))
                      y3 (ff/sub (ff/mul s  (ff/sub x1 x3))
                                 y1)]
                  [x3 y3])

      :else (let [s (ff/div (ff/sub y2 y1)
                            (ff/sub x2 x1))
                  x3 (ff/sub (ff/sub (ff/pow s 2) x1) x2)
                  y3 (ff/sub (ff/mul s (ff/sub x1 x3))
                             y1)]
              [x3 y3]))))


(defn smul [a b point scalar]
  (loop [acc point
         n scalar]
    (if (= n 1) acc
        (recur (add acc point a b)
               (dec n)))))

(defn big-and
  [f & r]
  (reduce (fn [acc v] (.and acc (biginteger v))) (biginteger f) r))

(defn bsmul [a b point scalar prime]
  (loop [coef (biginteger scalar)
         current point
         result (infinity-point prime)]
    (if (zero? coef) result
        (recur (.shiftRight coef 1)
               (add current current a b)
               (if (= 1 (big-and coef 1)) (add result current a b)
                   result)))))

(comment
  ;; points inside a curve
  (let [curve [[0 223] [7 223]]
        points [[[192 223]  [105 223]]
                [[17  223]  [56 223]]
                [[200 223]  [119 223]]
                [[1  223]  [193 223]]
                [[42  223]  [99 223]]]]
    (filter
     #(in? % curve) points)))


(comment
  ;; 2 ⋅ (192,105)
  (add
   [[192 223]  [105 223]]
   [[192 223]  [105 223]]
   [0 223] [7 223])

  (bsmul [0 223] [7 223]
         [[192 223]  [105 223]] 2 223)

;; 2 ⋅ (143,98)
  (add
   [[143 223]  [98 223]]
   [[143 223]  [98 223]]
   [0 223] [7 223])

  (bsmul [0 223] [7 223]
         [[143 223]  [98 223]] 2 223)

;; 2 ⋅ (47,71)
  (add
   [[47 223]  [71 223]]
   [[47 223]  [71 223]]
   [0 223] [7 223])

  (bsmul [0 223] [7 223]
         [[47 223]  [71 223]] 2 223)

;; 4 ⋅ (47,71)
  (add
   [[47 223]  [71 223]]
   (add
    [[47 223]  [71 223]]
    (add
     [[47 223]  [71 223]]
     [[47 223]  [71 223]]
     [0 223] [7 223])
    [0 223] [7 223])
   [0 223] [7 223])

  (bsmul [0 223] [7 223]
         [[47 223]  [71 223]] 4 223)


;; 8 ⋅ (47,71)
  (smul [0 223] [7 223] [[47 223]  [71 223]] 8)
  (bsmul [0 223] [7 223] [[47 223]  [71 223]] 8 223)

  (smul [0 223] [7 223] [[47 223]  [71 223]] 4)
  (bsmul [0 223] [7 223] [[47 223]  [71 223]] 4 223)

  (smul [0 223] [7 223] [[47 223]  [71 223]] 21)
  (bsmul [0 223] [7 223] [[47 223]  [71 223]] 21 223)


  ;;
  )



(comment
;; find order group generated by (15, 86) on F223

  (let [a [0 223]
        b [7 223]
        x [15 223]
        y [86 223]]
    (loop [p [x y]
           count 1]
      (pprint/pprint [p count])
      (if (= infinity-point p) count
          (recur (add p [x y] a b)
                 (inc count))))))
